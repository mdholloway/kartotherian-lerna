'use strict';

var _ = require('underscore');
var assert = require('assert');
var Job = require('./lib/Job');
var JobProcessor = require('./lib/JobProcessor');
var Promise = require('bluebird');

/**
 * Generates values as given by the iterator
 * @param {array} values
 * @param {int} [idxFrom]
 * @param {int} [idxBefore]
 * @returns {Function}
 */
function generator(values, idxFrom, idxBefore) {
    var i = 0;
    return function () {
        var result = undefined;
        while (idxFrom !== undefined && i < values.length && values[i] < idxFrom) {
            i++;
        }
        if (i < values.length && (idxBefore === undefined || values[i] < idxBefore)) {
            result = {idx: values[i++]};
        }
        return Promise.resolve(result);
    }
}


/**
 * Checks that values generated by the iterator match expected values
 * Adapted from promistreamus tests
 */
function assertInOrder(msg, expectedValues, iterator) {
    var pos = 0;
    var processor = function () {
        return iterator().then(function (value) {
            if (value === undefined) {
                assert.equal(pos, expectedValues.length, 'finished early');
                return undefined;
            }
            assert(pos < expectedValues.length, 'too many values');
            assert.deepEqual(value, {idx: expectedValues[pos++]}, 'unexpected value');

            return processor();
        });
    };
    return processor().catch(function (err) {
        err.message = msg + ': ' + err.message;
        assert.fail(err);
    });
}

function newJob(opts) {
    return {
        data: _.extend({
            storageId: 'sid',
            generatorId: 'gid'
        }, opts)
    };
}


function test(msg, expectedValues, tiles, filters, sourceData, hasQuery) {
    if (hasQuery) {
        msg += '+';
        sourceData.gid.z2 = expectedValues;
    }
    var sources = {
        getHandlerById: function (id) {
            return (hasQuery && id === 'gid') ? {
                query: function (opts) {
                    assert(id in sourceData, msg + ' id in sourceData: ' + id);
                    var dat = sourceData[id];
                    assert.notStrictEqual(opts.zoom, undefined, msg + ' has no zoom');
                    var zid = 'z'+opts.zoom;
                    assert(zid in dat, msg + ' id in sourceData: ' + id);
                    return generator(dat[zid], opts.idxFrom, opts.idxBefore);
                }
            } : {};
        }
    };
    var jp = new JobProcessor(sources, newJob({zoom: 2, tiles: tiles, filters: filters}));
    jp.stats = {};
    jp.tileStore = sources.getHandlerById('sid');
    jp.tileGenerator = sources.getHandlerById('gid');
    return assertInOrder(msg, expectedValues, jp.getIterator())
        .then(function () {
            if (!hasQuery) {
                return test(msg, expectedValues, tiles, filters, sourceData, true);
            }
        });
}


return Promise.resolve(true)
    .then(function () {return test('c06', [4,5],   [[0,6]], [{zoom:-1}], { gid:{}, sid:{z1:[1]} } )})
    ;
